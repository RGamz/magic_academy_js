<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width,initial-scale=1">
        <style>

            /* =========================
            Variables & base reset
            ========================= */
            :root{
            --bg:#f6f7fb;
            --card:#ffffff;
            --text:#111;
            --muted:#666;
            --primary:#4b7cff;
            --pill:#e8f0ff;
            --border:#e6e7ec;
            --radius:14px;
            --shadow:0 6px 20px rgba(0,0,0,.06);
            --container:clamp(960px,92vw,1680px);
            }

            *{box-sizing:border-box}
            html,body{height:100%}
            body{
            margin:0;
            font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
            background:var(--bg);
            color:var(--text);
            line-height:1.45;
            -webkit-font-smoothing:antialiased;
            text-rendering:optimizeLegibility;
            }
            img{max-width:100%;display:block}

            /* =========================
            A11y helpers
            ========================= */
            .skip-link{
            position:absolute;left:-999px;top:auto;width:1px;height:1px;overflow:hidden;
            }
            .skip-link:focus{
            left:12px;top:12px;width:auto;height:auto;padding:8px 12px;
            background:#000;color:#fff;border-radius:8px;z-index:1000;
            }
            .sr-only{position:absolute;left:-10000px;top:auto;width:1px;height:1px;overflow:hidden}

            /* =========================
            Layout / header / nav
            ========================= */
            .container{max-width:var(--container);margin:0 auto;padding:16px}
            .header-container{
            display:flex;align-items:center;gap:12px;padding:0;
            }
            .site-header{
            background:var(--card);
            border-bottom:1px solid var(--border);
            position:sticky;top:0;z-index:10;
            }
            .brand{margin:0;font-size:1.2rem}
            .site-nav{display:flex;gap:12px;align-items:center}
            .site-nav a{
            color:var(--text);text-decoration:none;
            padding:8px 10px;border-radius:8px;
            }
            .site-nav a[aria-current="page"]{background:var(--pill)}

            /* =========================
            Home: cards
            ========================= */
            .hero h2{margin:0 0 4px}
            .muted,.mute{color:var(--muted)}

            .card-grid{
            display:grid;gap:16px;margin-top:16px;
            grid-template-columns:repeat(3,1fr);
            }
            .card{
            background:var(--card);border:1px solid var(--border);
            border-radius:var(--radius);box-shadow:var(--shadow);overflow:hidden;
            }
            .card-link{display:block;color:inherit;text-decoration:none;height:100%}
            .card-media{position:relative;aspect-ratio:16/9;overflow:hidden}
            .card-media img{width:100%;height:100%;object-fit:cover}
            .pill{
            position:absolute;left:10px;top:10px;
            background:var(--pill);padding:6px 10px;border-radius:999px;font-size:.8rem;
            }
            .card-body{padding:12px 14px}
            .card-body h4{margin:0 0 6px;font-size:1rem}

            /* =========================
            Lesson layout
            ========================= */
            .lesson-layout{
            display:grid;gap:16px;align-items:start;
            grid-template-columns:2fr 1fr;
            }
            .lesson-media{width:100%}
            .lesson-side{position:relative}

            .panel{
            position:sticky;top:84px;
            background:var(--card);border:1px solid var(--border);
            border-radius:var(--radius);box-shadow:var(--shadow);padding:16px;
            }

            /* main illustration: max size w/o cropping */
            .media-wrap{
            margin:0;background:#fff;border-radius:var(--radius);
            overflow:hidden;box-shadow:var(--shadow);border:1px solid var(--border);
            display:flex;align-items:center;justify-content:center;
            }
            .media-large{
            width:100%;height:auto;display:block;
            max-height:min(84vh,1400px);
            object-fit:contain;
            }

            /* =========================
            Tasks (details/summary)
            ========================= */
            .task{
            border:1px solid var(--border);
            border-radius:var(--radius);
            background:var(--card);
            box-shadow:var(--shadow);
            margin:10px 0;overflow:hidden;
            }
            .task + .task{margin-top:16px}

            .task-summary{
            list-style:none;cursor:pointer;
            display:flex;align-items:center;padding:0;
            }
            .task-summary::-webkit-details-marker{display:none}
            .task-summary::before{
            content:"â–¸";display:inline-block;margin:0 8px 0 12px;
            transform:translateY(2px);transition:transform .2s ease;color:var(--muted);font-size:1rem;
            }
            .task[open] .task-summary::before{transform:rotate(90deg) translateX(-1px)}

            .bubble{
            background:var(--pill);
            border-radius:12px;
            padding:12px;margin:8px 12px 10px;
            }
            .task-body{padding:0 12px 12px}
            .text p{margin:0 0 6px}

            .sep{border:none;border-top:1px solid var(--border);margin:14px 0}

            /* =========================
            Buttons & utils
            ========================= */
            .row{display:flex;gap:10px;flex-wrap:wrap}
            .btn{
            appearance:none;border:1px solid var(--border);background:#fff;
            padding:10px 14px;border-radius:10px;cursor:pointer;
            }
            .btn:hover{border-color:var(--primary)}
            .btn.ghost{background:transparent}
            .hidden{display:none}
            .w100{width:100%}

            /* =========================
            Skeleton placeholders
            ========================= */
            .skeleton .card-media{background:#eee;height:0;padding-bottom:56%}
            .skeleton-line{height:14px;background:#eee;border-radius:8px;margin:8px 0}
            .skeleton-line.short{width:60%}

            /* =========================
            Media queries
            ========================= */
            @media (min-width:1600px){
            .card-grid{grid-template-columns:repeat(4,1fr)}
            }
            @media (min-width:1400px){
            .lesson-layout{grid-template-columns:2.5fr 1fr}
            }
            @media (min-width:1800px){
            .lesson-layout{grid-template-columns:3fr 1fr}
            }
            @media (max-width:1024px){
            .card-grid{grid-template-columns:repeat(2,1fr)}
            }
            @media (max-width:800px){
            .lesson-layout{grid-template-columns:1fr}
            .panel{position:static}
            }
            @media (max-width:640px){
            .task .bubble{margin:8px;width:calc(100% - 16px)}
            .task-body{padding:0 8px 10px}
            }

            /* =========================
            Reduced motion
            ========================= */
            @media (prefers-reduced-motion:reduce){
            *{scroll-behavior:auto;animation:none;transition:none}
            }
            .task[open] .task-body{animation:fadeIn .16s ease-out}
            @keyframes fadeIn{
            from{opacity:0;transform:translateY(-2px)}
            to{opacity:1;transform:translateY(0)}
            }

            .game_section {
            display: flex;
            justify-content: center;
            }
            /* ========= Base / Defaults ========= */
            *,
            *::before,
            *::after { box-sizing: border-box; }

            :root{
            /* layout */
            --container-w: 90%;
            --container-max: 1200px;
            --container-h: 100%;

            /* cards */
            --card-w: 50%;
            --card-h: 4rem;          /* fixed height for consistent layout (no conflicting flex+max-height) */
            --card-radius: 12px;
            --card-gap-col: 0.8rem;
            --card-gap-row: 1%;

            /* colors */
            --text-dark: #111;

            /* effects */
            --drag-shadow: 0 2px 8px rgba(0,0,0,.12);
            }

            /* ========= Main container ========= */
            .game_container {
            font-family: "Monaco", Monospace, sans-serif;
            display: flex;
            justify-content: space-between;
            align-items: stretch;
            width: var(--container-w);
            max-width: var(--container-max);
            height: var(--container-h);         /* cards will stretch to container height distribution-wise */
            gap: var(--card-gap-row);
            background-image: linear-gradient(43deg, #495dbd 0%, #C850C0 46%, #FFCC70 100%);
            padding: 1% 0 3%;
            }

            /* ========= Columns ========= */
            .left,
            .right {
            flex: 1 1 0;
            display: flex;
            flex-direction: column;
            justify-content: space-evenly;       /* evenly distribute vertically */
            align-items: center;
            gap: var(--card-gap-col);
            }

            /* ========= Cards (shared) ========= */
            .dragElement,
            .dropZone {
            width: var(--card-w);
            height: var(--card-h);               /* fixed, avoids layout thrash while dragging */
            flex: 0 0 var(--card-h);             /* prevent vertical stretching conflicts */
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: var(--card-radius);
            text-align: center;
            transition: transform .2s ease, box-shadow .2s ease, background-color .2s ease;
            /* Touch + selection hygiene */
            touch-action: none;
            user-select: none;
            }

            /* ========= Draggable cards ========= */
            .dragElement {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(4px);
            }

            .dragElement h3 {
            margin: 0;
            color: var(--text-dark);
            }

            /* Performance: lighten visuals during drag */
            .dragElement.beingDragged {
            /* Disable heavy filters while moving to keep 60fps */
            backdrop-filter: none !important;
            -webkit-backdrop-filter: none !important;
            box-shadow: var(--drag-shadow) !important;
            cursor: grabbing;
            /* Create a compositor layer only while dragging */
            will-change: transform;
            transform: translateZ(0);
            z-index: 10;
            }

            /* ========= Drop zones ========= */
            .dropZone {
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(6px);
            display: flex;                    /* already true in your code */
            align-items: center;
            justify-content: center;
            overflow: hidden;                 /* avoid corner bleed */
            }

            /* Reduce heavy visuals on hover state */
            .dropZone.hoverOver {
            box-shadow: none !important;
            }

            /* Optional success styling (if you add a 'filled' class in JS) */
            .dropZone.filled {
            border: 2px solid #228B22;
            overflow: hidden; /* avoids corner bleed when a child fills the zone */
            }


            .dropZone > .dragElement {
            flex: 1 1 auto !important;        /* override flex-basis: 5rem */
            width: 100% !important;
            height: 100% !important;
            border-radius: inherit;           /* match zoneâ€™s rounded corners */
            transform: none !important;       /* clear any translate from dragging */
            }


            /* ========= Color backgrounds ========= */
            .noir   { background-color: #000; }
            .blanc  { background-color: #fff; }
            .rouge  { background-color: red; }
            .vert   { background-color: green; }
            .jaune  { background-color: yellow; }
            .orange { background-color: rgb(255, 123, 0); }
            .rose   { background-color: rgb(255, 52, 255); }
            .gris   { background-color: rgb(187, 187, 187); }
            .bleu   { background-color: blue; }
            .violet { background-color: rgb(153, 0, 255); }


            .speak-btn {
            background: none;
            border: none;
            font-size: 1.1rem;
            margin-left: .5rem;
            cursor: pointer;
            }

            .speak-btn:hover { transform: scale(1.2); }
            .speak-btn:active { transform: scale(0.95); }

            /* ========= Reduced motion ========= */
            @media (prefers-reduced-motion: reduce) {
            .dragElement,
            .dropZone {
                transition: none;
            }
            }

            /* ========= Small screens ========= */
            @media (max-width: 800px) {
            :root{
                --card-w: 70%;
                --card-h: 4.25rem;
            }

            .game_container {
                height: 100%;             /* let content size naturally on mobile */
            }

            .left,
            .right {
                gap: 0.5rem;
            }
            }

        </style>
    </head>

    <body>
        <a class="skip-link" href="#main">Aller au contenu</a>

        <header class="site-header">
            <div class="container">
            <h1 class="brand">Lâ€™AcadÃ©mie des Mots Magiques</h1>
            <nav class="site-nav" aria-label="Navigation principale">
                <a href="./index.html" aria-current="page">Accueil</a>
                <a href="./games.html" aria-current="page">Jeux</a> 
            </nav>
            </div>
        </header>

        <section class="game_section">
            <div class="game_container">
                <div class="left">
                    <div class="dragElement" id="noir" draggable="true">
                        <h3>Noir</h3>
                        <button class="speak-btn" aria-label="Play pronunciation">
                            ðŸ”Š
                        </button>
                    </div>
                    <div class="dragElement" id="blanc" draggable="true">
                        <h3>Blanc</h3>
                        <button class="speak-btn" aria-label="Play pronunciation">
                            ðŸ”Š
                        </button>
                    </div>
                    <div class="dragElement" id="rouge" draggable="true">
                        <h3>Rouge</h3>
                        <button class="speak-btn" aria-label="Play pronunciation">
                            ðŸ”Š
                        </button>
                    </div>
                    <div class="dragElement" id="vert" draggable="true">
                        <h3>Vert</h3>
                        <button class="speak-btn" aria-label="Play pronunciation">
                            ðŸ”Š
                        </button>
                    </div>
                    <div class="dragElement" id="jaune" draggable="true">
                        <h3>Jaune</h3>
                        <button class="speak-btn" aria-label="Play pronunciation">
                            ðŸ”Š
                        </button>
                    </div>
                    <div class="dragElement" id="orange" draggable="true">
                        <h3>Orange</h3>
                        <button class="speak-btn" aria-label="Play pronunciation">
                            ðŸ”Š
                        </button>
                    </div>
                    <div class="dragElement" id="rose" draggable="true">
                        <h3>Rose</h3>
                        <button class="speak-btn" aria-label="Play pronunciation">
                            ðŸ”Š
                        </button>
                    </div>
                    <div class="dragElement" id="gris" draggable="true">
                        <h3>Gris</h3>
                        <button class="speak-btn" aria-label="Play pronunciation">
                            ðŸ”Š
                        </button>
                    </div>
                    <div class="dragElement" id="bleu" draggable="true">
                        <h3>Bleu</h3>
                        <button class="speak-btn" aria-label="Play pronunciation">
                            ðŸ”Š
                        </button>
                    </div>
                    <div class="dragElement" id="violet" draggable="true">
                        <h3>Violet</h3>
                        <button class="speak-btn" aria-label="Play pronunciation">
                            ðŸ”Š
                        </button>
                    </div>
                </div>

                <div class="right">
                    <div class="dropZone noir"></div>
                    <div class="dropZone blanc"></div>
                    <div class="dropZone rouge"></div>
                    <div class="dropZone vert"></div>
                    <div class="dropZone jaune"></div>
                    <div class="dropZone orange"></div>
                    <div class="dropZone rose"></div>
                    <div class="dropZone gris"></div>
                    <div class="dropZone bleu"></div>
                    <div class="dropZone violet"></div>
                </div>
            </div>
        </section>
        
    <script src="https://cdn.jsdelivr.net/npm/interactjs/dist/interact.min.js"></script>

    <script>

         // Select the container that holds all draggable elements
        const leftContainer = document.querySelector('.left');

        // Get all draggable elements as an array
        const draggablesArray = Array.from(leftContainer.children);

        // Fisherâ€“Yates shuffle algorithm
        for (let i = draggablesArray.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [draggablesArray[i], draggablesArray[j]] = [draggablesArray[j], draggablesArray[i]];
        }

        // Re-append shuffled elements back into the container
        draggablesArray.forEach(el => leftContainer.appendChild(el));

        // cache references for later use
        const draggables = document.querySelectorAll('.dragElement');
        const dropZones  = document.querySelectorAll('.dropZone');

        // helper: lock a card inside a dropzone after a correct drop
        function lockInto(zone, card) {
            zone.appendChild(card);                         // move into zone (disappears from left list)
            card.style.transform = 'none';                  // reset any dragging translation
            card.removeAttribute('data-x');                 // clear stored offsets
            card.removeAttribute('data-y');
            card.setAttribute('draggable', 'false');        // prevent native DnD
            card.style.width = '100%';                      // fill the zone fully
            card.style.height = '100%';
            card.style.pointerEvents = 'none';              // ignore further pointer events
            card.style.margin = 0;
            card.style.background = 'rgba(255, 255, 255, 0.7)'; // slight visual change on success
            zone.style.border = 'solid #228B22';            // success border on zone
            zone.style.overflow = 'hidden';                 // hide rounded-corner bleed
        }

        // make .dragElement draggable (works on mouse + touch)
        interact('.dragElement').draggable({
            listeners: {
            // update position on each move
            move (event) {
                const target = event.target;
                const x = (parseFloat(target.getAttribute('data-x')) || 0) + event.dx; // accumulate delta x
                const y = (parseFloat(target.getAttribute('data-y')) || 0) + event.dy; // accumulate delta y
                target.style.transform = `translate(${x}px, ${y}px)`;                  // visually move
                target.setAttribute('data-x', x);                                      // store new x
                target.setAttribute('data-y', y);                                      // store new y
            },
            // small visual cue when dragging starts/ends
            start (event) {
                event.target.classList.add('beingDragged');                            // add dragging style
            },
            end (event) {
                event.target.classList.remove('beingDragged');                         // remove dragging style
            }
            }
        });

        // make .dropZone accept drops
        interact('.dropZone').dropzone({
            accept: '.dragElement',          // only our cards
            overlap: 0.25,                   // must overlap at least 25%

            // highlight when a draggable enters the zone
            ondragenter (event) {
                event.target.classList.add('hoverOver'); // same CSS class you already use
            },

            // remove highlight when it leaves
            ondragleave (event) {
                event.target.classList.remove('hoverOver');
            },

            // handle the actual drop
            ondrop (event) {
            const zone   = event.target;            // the zone element
            const card   = event.relatedTarget;     // the dragged .dragElement
            const colorId = card.id;                // e.g. "rouge"
            
            // only allow one card per zone
            if (zone.querySelector('.dragElement')) return;

            // allow drop only if zone has matching color class (e.g., .rouge)
            if (!zone.classList.contains(colorId)) {
                // brief "wrong" feedback
                card.style.backgroundColor = 'red';
                setTimeout(() => { card.style.backgroundColor = 'rgba(255, 255, 255, 0.9)'; }, 120);
                return; // do not lock in
            }

            // correct drop â†’ lock the card into the zone
            lockInto(zone, card);
            },

            // cleanup highlight after drop completes
            ondropdeactivate (event) {
            event.target.classList.remove('hoverOver');
            }
        });

        interact('.dragElement').draggable({
            listeners: {
                start (event) {
                const t = event.target;
                t.classList.add('beingDragged');     // enables cheaper CSS above
                // optional: keep it on top while moving (avoids overlap paints)
                t.style.zIndex = 1000;
                },
                move (event) {
                const target = event.target;
                const x = (parseFloat(target.getAttribute('data-x')) || 0) + event.dx;
                const y = (parseFloat(target.getAttribute('data-y')) || 0) + event.dy;
                target.style.transform = `translate3d(${x}px, ${y}px, 0)`;  // 3d -> GPU
                target.setAttribute('data-x', x);
                target.setAttribute('data-y', y);
                },
                end (event) {
                const t = event.target;
                t.classList.remove('beingDragged');  // restore visuals after drop
                t.style.zIndex = '';                 // reset stacking
                }
            }
            });

            // --- Audio player for color pronunciations ---
            const audioBasePath = '../backend/assets/audio/colors/'; // adjust path if needed
            const audioCache = {}; // store loaded audio elements for reuse

            document.querySelectorAll('.speak-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation(); // prevent interfering with drag
                const colorId = btn.closest('.dragElement').id;
                const filePath = `${audioBasePath}${colorId}.mp3`;

                // reuse cached audio if already created
                let audio = audioCache[colorId];
                if (!audio) {
                    audio = new Audio(filePath);
                    audioCache[colorId] = audio;
                }

                // rewind and play
                audio.currentTime = 0;
                audio.play().catch(err => console.warn('Audio play error:', err));
            });
            });


    </script>

    </body>
</html>
